<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Versant Media - Global Locations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: #0a0a0a;
            color: white;
            overflow: hidden;
        }

        #header {
            background: #0a0a0a;
            border-bottom: 1px solid #333;
            padding: 24px;
        }

        .header-content {
            max-width: 1280px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2.25rem;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .subtitle {
            color: #9ca3af;
            font-size: 1.125rem;
        }

        #globe-container {
            width: 100%;
            height: calc(100vh - 120px);
            position: relative;
        }

        #location-info {
            position: absolute;
            top: 50%;
            right: 80px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #829CB2;
            border-radius: 12px;
            padding: 40px;
            max-width: 400px;
            min-width: 350px;
            display: none;
            box-shadow: 0 10px 40px rgba(130, 156, 178, 0.3);
        }

        #location-info.active {
            display: block;
        }

        .location-city {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 16px;
            color: #ffffff;
        }

        .location-country {
            color: #829CB2;
            font-size: 1.5rem;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .location-name {
            color: #9ca3af;
            font-size: 1.125rem;
        }

        .close-btn {
            position: absolute;
            top: 24px;
            right: 24px;
            background: none;
            border: none;
            color: #9ca3af;
            font-size: 2rem;
            cursor: pointer;
            line-height: 1;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            color: white;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
        }

        #instructions {
            position: absolute;
            bottom: 24px;
            left: 24px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 16px;
        }

        .instruction-text {
            color: #9ca3af;
            font-size: 0.875rem;
            margin-bottom: 8px;
        }

        .instruction-text:last-child {
            margin-bottom: 0;
        }
    </style>
</head>
<body>
    <div id="header">
        <div class="header-content">
            <h1>VERSANT Media</h1>
            <p class="subtitle">Global Locations</p>
        </div>
    </div>
    
    <div id="globe-container"></div>
    
    <div id="location-info">
        <button class="close-btn" onclick="closeLocationInfo()">Ã—</button>
        <div class="location-city" id="location-city"></div>
        <div class="location-country" id="location-country"></div>
        <div class="location-name" id="location-name"></div>
    </div>
    
    <div id="instructions">
        <p class="instruction-text">Click and drag to rotate</p>
        <p class="instruction-text">Click markers for location details</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const locations = [
            { name: 'New York, NY', lat: 40.7128, lon: -74.0060, city: 'New York', country: 'USA' },
            { name: 'Englewood Cliffs, NJ', lat: 40.8826, lon: -73.9474, city: 'Englewood Cliffs', country: 'USA' },
            { name: 'Orlando, FL', lat: 28.5383, lon: -81.3792, city: 'Orlando', country: 'USA' },
            { name: 'Washington D.C.', lat: 38.9072, lon: -77.0369, city: 'Washington', country: 'USA' },
            { name: 'Los Angeles, CA', lat: 34.0522, lon: -118.2437, city: 'Los Angeles', country: 'USA' },
            { name: 'Minneapolis, MN', lat: 44.9778, lon: -93.2650, city: 'Minneapolis', country: 'USA' },
            { name: 'Stamford, CT', lat: 41.0534, lon: -73.5387, city: 'Stamford', country: 'USA' },
            { name: 'London', lat: 51.5074, lon: -0.1278, city: 'London', country: 'UK' },
            { name: 'Belfast', lat: 54.5973, lon: -5.9301, city: 'Belfast', country: 'UK' },
            { name: 'South Africa', lat: -30.5595, lon: 22.9375, city: 'Johannesburg', country: 'South Africa' },
            { name: 'France', lat: 48.8566, lon: 2.3522, city: 'Paris', country: 'France' },
            { name: 'UAE', lat: 25.2048, lon: 55.2708, city: 'Dubai', country: 'UAE' },
            { name: 'Singapore', lat: 1.3521, lon: 103.8198, city: 'Singapore', country: 'Singapore' },
            { name: 'Hong Kong', lat: 22.3193, lon: 114.1694, city: 'Hong Kong', country: 'China' }
        ];

        let scene, camera, renderer, globe, markers = [];
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationVelocity = { x: 0, y: 0 };
        let isAnimatingToLocation = false;
        let targetRotation = { x: 0, y: 0 };
        let currentRotation = { x: 0, y: 0 };
        let autoRotate = true;

        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);
            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);
            return new THREE.Vector3(x, y, z);
        }

        function init() {
            const container = document.getElementById('globe-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);

            camera = new THREE.PerspectiveCamera(
                45,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.z = 3;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            const textureLoader = new THREE.TextureLoader();
            const texture = textureLoader.load('/img/EarthTexture.jpg');

            const globeGeometry = new THREE.SphereGeometry(1, 64, 64);
            const globeMaterial = new THREE.MeshPhongMaterial({
                map: texture,
                shininess: 10,
                specular: 0x222222
            });
            globe = new THREE.Mesh(globeGeometry, globeMaterial);
            scene.add(globe);

            locations.forEach((location) => {
                const markerGeometry = new THREE.SphereGeometry(0.025, 32, 32);
                const markerMaterial = new THREE.MeshPhongMaterial({
                    color: 0x829CB2,
                    shininess: 100,
                    specular: 0xffffff,
                    reflectivity: 1
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                
                const pos = latLonToVector3(location.lat, location.lon, 1.0125);
                marker.position.copy(pos);
                marker.userData = { location };
                
                scene.add(marker);
                markers.push(marker);
            });

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 1.2, 100);
            pointLight.position.set(5, 3, 5);
            scene.add(pointLight);

            const pointLight2 = new THREE.PointLight(0x4466ff, 0.3, 100);
            pointLight2.position.set(-5, -3, -5);
            scene.add(pointLight2);

            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('click', onClick);

            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function onMouseDown(e) {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        function onMouseMove(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                rotationVelocity.x = deltaY * 0.005;
                rotationVelocity.y = deltaX * 0.005;
                
                globe.rotation.y += rotationVelocity.y;
                globe.rotation.x += rotationVelocity.x;
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onClick() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(markers);
            
            if (intersects.length > 0) {
                const clickedMarker = intersects[0].object;
                const location = clickedMarker.userData.location;
                autoRotate = false;
                animateToLocation(location, clickedMarker);
                showLocationInfo(location);
            } else {
                closeLocationInfo();
                autoRotate = true;
            }
        }

        function animateToLocation(location, marker) {
            const basePos = latLonToVector3(location.lat, location.lon, 1.02);
            
            const targetY = -Math.atan2(basePos.x, basePos.z);
            const targetX = Math.asin(basePos.y / 1.02);
            
            targetRotation.y = targetY;
            targetRotation.x = targetX;
            
            isAnimatingToLocation = true;
            rotationVelocity = { x: 0, y: 0 };
        }

        function normalizeAngle(angle) {
            while (angle > Math.PI) angle -= 2 * Math.PI;
            while (angle < -Math.PI) angle += 2 * Math.PI;
            return angle;
        }

        function showLocationInfo(location) {
            document.getElementById('location-city').textContent = location.city;
            document.getElementById('location-country').textContent = location.country;
            document.getElementById('location-name').textContent = location.name;
            document.getElementById('location-info').classList.add('active');
        }

        function closeLocationInfo() {
            document.getElementById('location-info').classList.remove('active');
            autoRotate = true;
        }

        function onWindowResize() {
            const container = document.getElementById('globe-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (isAnimatingToLocation) {
                let dx = normalizeAngle(targetRotation.x - globe.rotation.x);
                let dy = normalizeAngle(targetRotation.y - globe.rotation.y);
                
                globe.rotation.x += dx * 0.1;
                globe.rotation.y += dy * 0.1;
                
                if (Math.abs(dx) < 0.01 && Math.abs(dy) < 0.01) {
                    globe.rotation.x = targetRotation.x;
                    globe.rotation.y = targetRotation.y;
                    isAnimatingToLocation = false;
                }
            } else if (!isDragging && autoRotate) {
                globe.rotation.y += 0.001;
            } else if (!isDragging) {
                rotationVelocity.x *= 0.95;
                rotationVelocity.y *= 0.95;
                globe.rotation.y += rotationVelocity.y;
                globe.rotation.x += rotationVelocity.x;
            }

            markers.forEach((marker, index) => {
                const location = locations[index];
                const pos = latLonToVector3(location.lat, location.lon, 1);
                
                const matrix = new THREE.Matrix4();
                matrix.makeRotationFromEuler(globe.rotation);
                pos.applyMatrix4(matrix);
                
                marker.position.copy(pos);
            });

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
